<h1 id="-windows-docker-azure-">連載：WindowsユーザーのためのDockerコンテナ入門（Azure活用編）</h1>
<h1 id="docker-docker-">Dockerホストの作製とDockerコンテナのロードまで</h1>
<blockquote>
<p>アバナード　旭 哲男<br>2016/mm/dd</p>
</blockquote>
<p>システム開発のライフサイクルのなかで見過ごされやすいタスクに、「環境の整備」があると著者は考えている。
熟練の開発者であれば、自分がこれから設計・開発・テストするための環境整備の方法を頭に思い描き、かつ整備することができると思うが、
チームに参画するメンバーすべてが一様に整備できるかというと、実際にはそんなことはなく、
できるメンバーがつきっきりで、環境を構築することが多いのではないだろうか。</p>
<p>またはテストも完了し、運用環境へのデプロイ作業を運用メンバーに依頼したが、システムが正しく作動せず、
結局開発メンバーがデプロイ作業を実施するなどして、お互いに不信感を持ってしまうということが発生していないだろうか。</p>
<p>これらの問題が発生する原因の一つには、環境整備には属人的な側面が多大にあり、たとえ完璧なマニュアルを整備したとしても
実際には、「予想外のことが起きて環境整備が完了しない」、「環境差異が発生してシステムが動かない」といったことがあり
わかる人間が都度対応せざるを得ないということ、そもそも完璧なマニュアルを作るということ自体が至難の業であるといえるだろう。</p>
<p>では、環境をより簡単に整備するにはどうしたらよいだろうか。環境を丸ごととっておき、それを必要に応じて使用できれば良いのではないだろうか。
環境を丸ごとコピーするという考え方自体は昔からある考え形であり、仮想マシンを活用すれば仮想マシンごと丸ごとコピーして、データセンターのホストや、
クラウドサービスにデプロイできるのはご存じのとおりである。</p>
<p>　Dockerもまた、環境を丸ごとDockerコンテナとして管理することができ、DockerコンテナをコピーしてDockerホストにデプロイするということができる。
では、Dockerコンテナと仮想マシンは何が違うのか。</p>
<p>一つには、Dockerコンテナは「必要最小限で構成された軽量のイメージであり、より少ないリソースで稼働できる」があげられるが、
これ以外にもDockerには、“コンテナをスタックする”、“コンテナをリポジトリで管理する”といった、
カスタマイズ・デプロイに特化した機能があり、CI(継続的インテグレーション)を実現するための重要なテクノロジであると注目されている。</p>
<p>従来はDockerを使うためにLinuxの知識が不可欠であったが、Azureクラウド環境を活用して、より容易にDockerを使えるようになった。
本稿では、WindowsユーザーがDockerホストを作成し、Dockerコンテナをロードするまでの手順を説明する。</p>
<blockquote>
<p>本稿では、Dockerのシステムアーキテクチャーについては触れていない。Dockerホスト、Dockerコンテナの
詳細については　<a href="https://www.docker.com/what-docker">What is Docker</a>　を参照のこと。</p>
</blockquote>
<hr>
<h2 id="-">前準備</h2>
<p>本稿では、DockerホストとしてAzure上のLinuxの仮想マシンを使用する。Linuxではあるが、ほとんどの設定をWindowsのコマンドから実行できるため、Linuxの知見がなくても問題ない。</p>
<blockquote>
<p>Windows Server 2016ではDockerホストの機能が提供される予定だが、
執筆時点ではDockerホストとして、Windows Server 2016を選択することができない。
Windows Server 2016でのDocker利用については、Windows Server 2016リリース後にあらためて説明する。</p>
</blockquote>
<p>Dockerホストを構築する前に、以下の準備が必要である。</p>
<ul>
<li>Microsoft Azureアカウント
アカウントのアクティベーションについては、<a href="https://azure.microsoft.com/ja-jp/free/">無料の Azure アカウントを今すぐ作成しましょう</a>を参照のこと。</li>
<li>クライアントPC
本稿ではWindows 10で操作しているが、Windows7/8/8.1でも動作可能。</li>
<li>インターネット接続環境
各種ツールのインストールおよび、Dockerコンテナを操作するためにインターネットへの接続環境が必要である。プロキシ経由での接続については本稿では扱わない。</li>
</ul>
<p>作業を進める中で、シェルを頻繁に変更する。記事中以下の表記が出てきたときは、それぞれシェルを使い分けていることに注意。</p>
<table>
<thead>
<tr>
<th>記載例</th>
<th>シェル</th>
<th>起動方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>PS&gt;</td>
<td>PowerShell</td>
<td>スタート→”PowerShell”を検索→アイコンを右クリックし「管理者として実行」</td>
</tr>
<tr>
<td>CMD&gt;</td>
<td>コマンドプロンプト</td>
<td>スタート→”CMD”を検索→クリック</td>
</tr>
<tr>
<td>SSH&gt;</td>
<td>Putty SSHセッション</td>
<td>PowerShellまたはコマンドプロンプトから”putty”を入力して起動</td>
</tr>
</tbody>
</table>
<p>Dockerホスト/コンテナを操作するためには、以下のツールのセットアップが必要である。</p>
<ol>
<li>Chocolatey（パッケージ管理ツール）</li>
<li>node.js / npm（JavaScript実行環境）</li>
<li>Azure-cli（Azure管理ツール）</li>
<li>Docker（Dockerクライアント）</li>
<li>Putty（SSHクライアント）</li>
</ol>
<p>以下順を追って説明する。</p>
<h3 id="chocolatey-">Chocolateyのインストール</h3>
<p>本稿では、各種ツールのインストールを <a href="https://chocolatey.org/">Chocolatey</a>で行う。
Chocolateyのインストールする前に、PowerShellの実行ポリシーが”Remote Signed”以上であることを確認する。
もし、”Restricted”や”Undefined”だった場合には“Remote Signed”変更すること。
実行ポリシーが”Remote Signed”以上であることを確認したら、Cocolateyをインストールする。</p>
<blockquote>
<p>以下 <strong>PS&gt;</strong>や<strong>CMD&gt;</strong> はプロンプトを意味している。実際の入力に当たっては PS&gt; より後の部分を入力すること。</p>
</blockquote>
<pre><code class="lang-Powershell">#実行ポリシーの確認
PS&gt; Get-ExecutionPolicy
#実行ポリシーの設定
PS&gt; Set-ExecutionPolicy RemoteSigned
#Chocolateyのインストール
PS&gt; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;)) 
#Chocolateyの動作確認
PS&gt; choco
</code></pre>
<h3 id="node-js-nmp-">node.js / nmpのインストール</h3>
<p>Azureの各種サービスを操作するために、Azure-cliを動作させるための実行環境としてnode.jsおよびnpmをインストールする。
すでに、Microsoft Web PIなどでインストール済みであれば次のステップへ。</p>
<pre><code class="lang-Powershell">#node.jsのインストール
PS&gt; choco install node.js
#npmのインストール
PS&gt; choco install npm
#npmの動作確認
CMD&gt; npm
</code></pre>
<blockquote>
<p>npmは、PowerShellではなく、コマンドプロンプトから起動できることに注意。
PowerShell上で作業を継続する場合には、PATH環境変数の内容を反映させるため、一度PowerShellを起動しなおすこと。</p>
</blockquote>
<h3 id="azure-cli-">Azure-cliのインストール</h3>
<p>Azureの管理ツールをインストールする。Azure Dockerホストを作成するためには、Azure-cliが必須である。</p>
<pre><code class="lang-Powershell">#Azure-cliのインストール
CMD&gt; npm install -g azure-cli
#azure-cliの動作確認
CMD&gt; azure help
</code></pre>
<h3 id="docker-">Dockerのインストール</h3>
<p>DockerコンテナをクライアントPCから操作する場合にインストールが必要である。
Dockerホストにアクセスして、直接Dockerコンテナを操作する場合は、インストール不要だがインストールしておくことを推奨する。</p>
<pre><code class="lang-Powershell">#Dockerクライアントのインストール
PS&gt; choco install docker
#Dockerクライアントの動作確認
PS&gt; docker help
</code></pre>
<h3 id="putty-">puttyのインストール</h3>
<p>Dockerホストに接続するために必要。Dockerホスト上でのストレージデバイスのマウントや、Dockerコンテナ用のディレクトリの作成など、
Dockerクライアントからは操作できないことは、Dockerホストに接続して実施する必要がある。</p>
<pre><code class="lang-Powershell">#puttyのインストール
PS&gt; choco install putty
#puttyの動作確認
PS&gt; putty
</code></pre>
<hr>
<h2 id="docker-">Dockerホストの作製</h2>
<p>ツールのインストールができたら、Docker環境を構築する。
Dockerを使用するためには、Dockerホストを用意しなければならない。現時点のAzureでは、DockerホストとしてLinux仮想マシンを使用することができる。
仮想マシンの作成には、Azure-cliを使用する。以下、順を追って説明する。</p>
<h3 id="azure-">Azureログイン</h3>
<p>まず初めに、Azure-cliでログインをする。以下の<code>CMD&gt; azure login</code>を実行し、出力されたURLと認証コードを確認する。
<img src="./azure-cli-login.JPG" alt="Azure login" title="Azure login"></p>
<p>出力されたURLを、ブラウザで開くと、以下のような画面になるので、先ほどの認証コードを入力する。
<img src="./azure-device-login.JPG" alt="Azure device login1" title="Azure device login1"></p>
<p>認証コードが正しい場合、端末からのアクセスを許容するかどうか質問されるので、「続行」ボタンを押す。
<img src="./azure-device-login2.JPG" alt="Azure device login2" title="Azure device login2"></p>
<p>さらに、Azureの認証アカウントを選択する。
<img src="./azure-device-login3.JPG" alt="Azure device login3" title="Azure device login3"></p>
<p>認証が成功すると以下のような画面になる、ブラウザを閉じ、Azure loginの結果を確認する。
<img src="./azure-device-login4.JPG" alt="Azure device login4" title="Azure device login4">
<img src="./azure-cli-login2.JPG" alt="Azure cli login2" title="Azure login2"></p>
<h3 id="azure-vm-">Azure VMイメージの確認</h3>
<p>Dockerホストを作製するための仮想マシンのOSイメージを選択する。<code>azure vm list</code>コマンドを実行し、
<strong>Ubuntu 14_04</strong>のイメージの名称をメモする。また、<code>azure vm show</code>コマンドを実行することで
仮想マシンの詳細を知ることができる。</p>
<p><img src="./azure-vm-list.JPG" alt="azure vm images" title="Azure VM list"></p>
<blockquote>
<p>ここでは、Ubuntu 14を選択したが、CentOSやDebianも選択可能である。
なお、Microsoft のAzure関連のブログ記事では Ubuntuで説明されていることが多いため、特段の要件がなければUbuntuを選択するのが良いだろう。</p>
</blockquote>
<h3 id="azure-docker-">Azure Docker ホストの作製</h3>
<p>いよいよDockerホストを作成する。本稿では、Dockerコンテナをロードできるまでを説明するため、デフォルト構成でホストを作製する。</p>
<pre><code class="lang-PowerShell">#Azure Dockerホスト作成コマンド
azure vm docker create -e 22 -l &quot;Japan East&quot; [ホスト名] &quot;仮想マシンイメージ&quot; [仮想マシンの管理ユーザ] [管理ユーザのパスワード]
</code></pre>
<p>ここでは以下のように設定した。４～５分程度でVMが生成される。</p>
<table>
<thead>
<tr>
<th>パラメータ</th>
<th>値</th>
</tr>
</thead>
<tbody>
<tr>
<td>ホスト名</td>
<td>BldinsDcrHst</td>
</tr>
<tr>
<td>仮想イメージ</td>
<td>b39f27a8b8c64d52b05eac6a62ebad85__Ubuntu-14_04_5-LTS-amd64-server-20160830-en-us-30GB</td>
</tr>
<tr>
<td>管理ユーザ名</td>
<td>builder</td>
</tr>
<tr>
<td>パスワード</td>
<td>Bu!lder123</td>
</tr>
</tbody>
</table>
<p><img src="./docker-host-create.JPG" alt="Azure docker host create" title="Azure docker host create"></p>
<p>実際に、Dockerを活用するためには、どのようなDockerコンテナをロードするのか、各コンテナはどのくらいのCPUリソース、メモリを消費するのかを
見極めたうえで、Dockerホストのスペックを決める必要がある。</p>
<blockquote>
<p>例えば、一般的なWebアプリケーション環境を構築するのであれば、Webサーバ、アプリケーションサーバ、データベースの
3つのコンテナをロードするのが一般的だろう。複数のコンテナを組み合わせて、環境を構築する手順については、第3回で解説する予定である。</p>
</blockquote>
<h3 id="docker-">Dockerホストの確認</h3>
<p>ホストが生成されたかどうかを確認する。<code>azure vm list</code>コマンドで、ホスト名が表示されているか確認し、<code>azure vm show</code>コマンドで
仮想マシンの状態を確認する。</p>
<pre><code class="lang-PowerShell">#Azure VMの一覧取得
CMD&gt; azure vm list
#VMの詳細
CMD&gt; azure vm show BldinsDcrHst
</code></pre>
<p><img src="./docker-host-show.JPG" alt="Azure docker host show" title="Azure docker host show"></p>
<h3 id="docker-ssh-">Dockerホストへの接続と、SSH暗号化キーの作製</h3>
<p>Azure Dockerホストにログインできるか確認する。puttyを起動（<code>putty</code>コマンドを実行）し、接続先情報を設定する。
Hostnameに先ほど確認した、ホストのFQDNを入力、Saved Sessionsに任意の接続名を入力して、「Save」ボタンを押下する。</p>
<p><img src="./putty1.JPG" alt="Putty config" title="Putty config"></p>
<p>「OK」ボタンを押すと、仮想マシンに接続する。Dockerホストを作成時に指定した、ユーザ名とパスワードを入力し接続できるか確認する。</p>
<p><img src="./putty3.JPG" alt="Putty login" title="Putty login"></p>
<p>この仮想マシンは初めから、Dockerホストとして構成されており、追加パッケージをインストールすることなく、Dockerコマンドを実行可能である。
試しに、Dockerの環境情報を取得し、ログアウトする。</p>
<pre><code class="lang-SH"># Docker環境情報の確認
SSH&gt; docker info
# 仮想マシンからログアウト
SSH&gt; exit
</code></pre>
<p>このままでも運用は可能だが、認証がパスワードだけというのは心細い、セキュリティを強化するためにSSHキーペアを作成する。</p>
<pre><code class="lang-CMD">CMD&gt; puttygen
</code></pre>
<p><img src="./putty-ssh1.JPG" alt="Putty ssh keygen" title="Putty ssh keygen"></p>
<p>「Generate」ボタンを押下し、Keyの領域で以下のような画面になるまでマウスを動かす。
生成されたキーペアはそれぞれ、後の認証で使用するので、「key passphrase（開錠のためのパスワード）」を入力し、
「Save public key」「Save private key」を押下して、ファイルとして保存すること。</p>
<p><img src="./putty-ssh3.JPG" alt="Putty ssh keyseve" title="Putty ssh keysave"></p>
<p>つぎに、Azure Portalにアクセスし、作成した仮想マシンを選択し、パスワードのリセットを選択、ユーザ名に管理ユーザ名、認証の種類として
<strong>SSH公開鍵</strong>を選択し、puttygenで生成されたpublicキーを入力する。</p>
<p><img src="./putty-ssh4.JPG" alt="Putty ssh publickey set" title="Putty ssh publickey set"></p>
<p>仮想マシンのパスワードがリセットされたら、puttyの接続設定を修正する。
puttyを起動し、接続設定画面が表示されたら、「Connection-SSH-Auth」を選択し、
Privte key file for authenticagtionに、puttygenで生成した秘密鍵のファイルパスを指定する。</p>
<p><img src="./putty-ssh5.JPG" alt="Putty ssh privatekey set" title="Putty ssh privatekey set"></p>
<p>SSH秘密鍵を指定すると、ログイン時に秘密鍵に対するパスワードを聞いてくるので、puttygenでキーペアを
生成したときに入力したパスワードを入力するとログインできる。</p>
<p><img src="./putty-ssh6.JPG" alt="Putty ssh login by sshkey" title="Putty ssh login by sshkey"></p>
<blockquote>
<p>ここで生成した、鍵ファイルとパスワードは大切に保管しなければならない。
これらがないと、ログインできなくなってしまうため、鍵ファイルを削除またはパスワードを忘れた場合には、
もう一度、SSHキーペアの作製と、仮想マシンのパスワードリセットが必要になる。</p>
<p>逆に言えば、秘密鍵ファイルとパスワードがあれば、仮想マシンにアクセスできるので、秘密鍵ファイルを
外部から参照できるようなところに置いてはいけない。</p>
</blockquote>
<hr>
<h2 id="docker-">Dockerコンテナの起動</h2>
<p>次にDockerコンテナを起動する。今回は、Dockerコンテナとして<strong>Nginxコンテナ</strong>を起動する。</p>
<p>システムのイメージは以下のようになる。Azure Dockerホストを作成すると、Azureクラウドサービス、Azureストレージ、Azure仮想マシンのリソースが
動的に割り当てられる。
仮想マシンには、OSとしてUbuntuがロードされ、Dockerホストが起動される。
さらに、Dockerホストに対して、Dockerコンテナの起動命令を出すことで、Dockerコンテナの読込と起動が行われる。</p>
<p><img src="./docker-load-image.JPG" alt="Docker Load Image" title="Docker Load Image"></p>
<p>まずは、SSHでDockerホストにアクセスし、以下のコマンドを実行し、Dockerのリポジトリ<code>Docker Hub</code>から取得できるコンテナを確認する。
Nginxコンテナのイメージがいくつか見つかる。”OFFICIAL”列が”OK”となっているものが、Docker公式のnginxのイメージであり、今回取得する対象のイメージである。</p>
<pre><code class="lang-SH">#DockerリポジトリでDockerコンテナを検索する
SSH&gt; docker search nginx
</code></pre>
<p><img src="./docker-load-search.JPG" alt="Docker search" title="Docker Search"></p>
<blockquote>
<p>その他のイメージは、第三者がDocker Hubで公開しているイメージである。
それぞれ個別のカスタマイズがされており、<a href="http://hub.docker.com">Docker Hub</a>にアクセスすることでその詳細を知ることができる。</p>
</blockquote>
<p>つぎに、Dockerコンテナを起動する。<code>docker run</code>コマンドを実行すると、Nginxコンテナイメージを取得し、Nginxコンテナが起動される。
また、<code>docker ps</code>コマンドを実行すると、起動中のDockerコンテナの一覧を確認できる。</p>
<p>起動に当たっては、以下のオプションを付与した。</p>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>サービスとして起動</td>
</tr>
<tr>
<td>-p ホストポート:コンテナのポート</td>
<td>コンテナの指定ポートをホストのポートにマップする。このオプションを付与しないとDockerホストの外から参照することができない。</td>
</tr>
<tr>
<td>--name</td>
<td>起動したコンテナに名前を付ける。このオプションをつけないと、コンテナを管理するときにコンテナの見分けがつかない。</td>
</tr>
</tbody>
</table>
<pre><code class="lang-SH">#Docker コンテナの起動例
SSH&gt; docker run -d -p 8080:80 --name some-nginx nginx
#起動中のDockerコンテナの一覧
SSH&gt; docker ps
</code></pre>
<p><img src="./docker-load-run.JPG" alt="Docker run" title="Docker run"></p>
<p>起動したnginxにアクセスするためには、Dockerホストのポート8080を開通させる必要がある。
Dockerホストを作成したPCから<code>azure vm endpoint create</code>コマンドを実行する。</p>
<pre><code class="lang-CMD">#Dockerホストのポート8080を開通する
CMD&gt; azure vm endpoint create BldinsDcrHst 8080 
#Dockerホストの開通しているポートの一覧を確認する
CMD&gt; azure vm endpoint list BldinsDcrHst
</code></pre>
<p><img src="./docker-load-portopen.JPG" alt="endpoint create" title="endpoint create"></p>
<p>ポート開通後は、ブラウザでアクセス可能になる。</p>
<p><img src="./docker-load-browser.JPG" alt="browser access" title="browser access"></p>
<p>ポート開通後は以下のような構成になる。
Dockerコンテナのポート（80）をDockerホストのポート(8080)にマップしなければ、外部から接続できないことに注意。</p>
<p><img src="./docker-load-portimage.JPG" alt="endpoint image" title="endpoint image"></p>
<blockquote>
<p>Dockerコンテナは起動されると、コンテナ間での通信のための仮想ネットワークに参加するが、
そのままではDockerホストの外部から、仮想ネットワークにアクセスすることはできない。<br>外部からアクセス可能な条件は、 「コンテナが、任意のポートをExposeし」、かつ「コンテナ起動時にDockerホストのポートにマップ」することが必要である。<br>さらに、インターネット経由でAzure仮想マシンにアクセスするためには、仮想マシンのEndpoint登録が必要になる。</p>
</blockquote>
<hr>
<h2 id="docker-">Dockerコンテナの停止</h2>
<p>最後にDockerコンテナをクライアントPCから管理する方法を兼ねて、コンテナを停止させる方法を説明する。</p>
<p>Dockerクライアントは、リモートからDockerホストに対してコンテナを管理することができる。
Azure-cliを使って、Dockerホストを作成した場合、DockerクライアントとDockerホスト間でSSL通信を行い、
Dockerホストをリモートから直接管理できるように構成される。</p>
<p><img src="./docker-stop-image.JPG" alt="Docker stop" title="Docker stop"></p>
<p>実際に、Dockerホストで稼働中のコンテナを確認するため<code>docker ps</code>コマンドを実行し、
先に起動したnginxコンテナを停止するために、<code>docker stop</code>コマンドを実行してみる。</p>
<pre><code class="lang-CMD">#リモートのDockerホストの実行中のコンテナを確認する
CMD&gt; docker --tlsverify -H tcp://[対象のDockerホスト]:2376 ps
#Dockerコンテナを停止させる
CMD&gt; docker --tlsverify -H tcp://[対象のDockerホスト]:2376 stop [コンテナ名]
#停止したか確認する
CMD&gt; docker --tlsverify -H tcp://[対象のDockerホスト]:2376 ps
</code></pre>
<p><img src="./docker-client-ps.JPG" alt="Docker client ps" title="Docker ps"></p>
<blockquote>
<p>Dockerコンテナを止めるためには、Dockerコンテナの名前を使用する。（今回の例では &quot;some-nginx&quot;）
もし、Dockerコンテナを起動するときに名前を付け忘れた場合は、CONTAINER IDを指定することでも操作できるのだが、
コマンドからは対象のコンテナなのか判別できないことがあるため注意が必要である。</p>
</blockquote>
<p>Dockerコンテナを削除しても、仮想マシンが稼働している間は課金されてしまう。
節約のため、Dockerコンテナの操作が終わったら仮想マシンを停止させる。</p>
<pre><code class="lang-CMD">#Dockerホストを停止させる
CMD&gt; azure vm shutdown BldinsDcrHst
#停止したか確認する
CMD&gt; azure vm list
</code></pre>
<p><img src="./azure-vm-shutdown.JPG" alt="Docker host Shutdown" title="Docker host Shutdown"></p>
<h1 id="-">最後に</h1>
<p>Azureクラウド環境に、Dockerホストを作成し、Dockerコンテナを起動、最後にDockerクライアントを使って、Dockerコンテナの停止までを
Windows - Azureクラウドの組み合わせで実施できることを解説した。
今回は、コンテナを単独で動かすところまでしか紹介できていないが、実際のDockerの活用シーンとしてはWeb-App-Dbのそれぞれに
コンテナを用意し、個別にまたはまとめてコンテナを起動・停止することが求められてくる。</p>
<p>次回は、分散キーストアである、<code>Cassandra</code>のコンテナを使い、複数コンテナの起動、コンテナ間の通信、
複数のDockerホストをまたがったDockerコンテナのロードについて解説する予定である。</p>
